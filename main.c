#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
// Fonction pour vérifier la priorité des opérateurs
int priorite(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// Conversion infixée -> postfixée (Retourne une chaîne postfixée)
void infixToPostfix(char *infix, char *postfix) {
    char stack[100][20];  // Pile pour les opérateurs
    int top = -1;
    int postfixIndex = 0;
    char temp[20];
    int index = 0;

    for (int i = 0; infix[i] != '\0'; i++) {
        char c = infix[i];

        if (isdigit(c) || c == '.') {  // Accumuler les nombres
            temp[index++] = c;
            temp[index] = '\0';
        } else {
            if (index > 0) {
                strcat(postfix, temp);  // Ajouter le nombre accumulé à la chaîne postfixée
                strcat(postfix, " ");
                index = 0;
            }

            if (c == '(') {
                strcpy(stack[++top], "(");
            } else if (c == ')') {
                while (top >= 0 && strcmp(stack[top], "(") != 0) {
                    strcat(postfix, stack[top--]);
                    strcat(postfix, " ");
                }
                top--;  // Retirer le '('
            } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                char op[2] = {c, '\0'};
                while (top >= 0 && priorite(stack[top][0]) >= priorite(c)) {
                    strcat(postfix, stack[top--]);
                    strcat(postfix, " ");
                }
                strcpy(stack[++top], op);
            }
        }
    }

    // Ajouter le dernier nombre accumulé
    if (index > 0) {
        strcat(postfix, temp);
        strcat(postfix, " ");
    }

    // Ajouter les opérateurs restants
    while (top >= 0) {
        strcat(postfix, stack[top--]);
        strcat(postfix, " ");
    }

    printf("Formule postfixe : %s\n", postfix);
}
// Fonction pour évaluer une expression postfixe
double evaluerPostfix(char *postfix) {
    double T[100];  // Tableau pour stocker les éléments de la pile
    int top = -1;   // Pointeur pour le sommet de la pile
    char *tokens[100]; // Tableau pour stocker les tokens de l'expression postfixe
    int token_count = 0;  // Compteur pour les tokens

    // Tokeniser la chaîne postfixe (séparée par des espaces)
    char *token = strtok(postfix, " ");
    while (token != NULL) {
        printf("Token: %s\n", token);  // Afficher chaque token

        // Stocker les tokens dans le tableau
        tokens[token_count++] = token;

        // Si le token est un nombre (positif ou négatif)
        if (isdigit(token[0]) || (token[0] == '-' && isdigit(token[1]))) {
            double value = atof(token); // Convertir en double
            T[++top] = value;  // Empiler dans T
            printf("Nombre empilé : %.6f\n", value);  // Afficher le nombre empilé avec 6 décimales
        } else {  // Si le token est un opérateur
            // Dépiler les deux derniers opérandes
            double b = T[top--];  // Dépile le second opérande
            double a = T[top--];  // Dépile le premier opérande

            double result;  // Variable pour le résultat de l'opération

            // Effectuer l'opération
            switch (token[0]) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': result = a / b; break;
                default:
                    printf("Opérateur inconnu : %c\n", token[0]);
                    return -1;  // Retourne une erreur si l'opérateur est invalide
            }

            // Empiler le résultat
            T[++top] = result;
            printf("Résultat intermédiaire (%f %c %f) : %.6f\n", a, token[0], b, result);  // Affichage précis
        }

        // Passer au token suivant
        token = strtok(NULL, " ");
    }

    // Afficher la formule postfixe après le calcul
    printf("Formule postfixe après calculs : ");
    for (int i = 0; i < token_count; i++) {
        printf("%s ", tokens[i]);
    }
    printf("\n");

    // Retourner le résultat final (le dernier élément dans T)
    return T[top];
}

int main() {
    char infix[100], postfix[200];

    // Demander à l'utilisateur d'entrer une expression infixée
    printf("Entrez une expression infixée : ");
    fgets(infix, sizeof(infix), stdin);
    infix[strcspn(infix, "\n")] = 0;  // Enlever le caractère '\n' à la fin de l'entrée

    // Initialisation de la chaîne postfixe vide
    strcpy(postfix, "");

    // Conversion de l'expression infixée en postfixée
    infixToPostfix(infix, postfix);

    // Évaluer l'expression postfixée
    double result = evaluerPostfix(postfix);
    
    // Affichage du résultat final
    printf("Résultat final : %.6f\n", result);

    return 0;
}